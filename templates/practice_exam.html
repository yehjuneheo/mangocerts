{% extends "base.html" %}
{% load static %}
{% block title %}Practice Exam{% endblock %}

{% block content %}
<head>
    <link rel="stylesheet" href="{% static 'practice.css' %}">
</head>
<div class="exam-container">
    <!-- Sidebar for Question Numbers -->
    <aside class="sidebar">
        <div class="sidebar-container">
            <button onclick="goBack()" id="back-btn" class="back-button">{{ translations.back }}</button>
            <h2>{{ translations.exam }} {{ test_number }} ({{ translations.review_mode }})</h2>
        </div>
        <ul id="question-list">
            <!-- Dynamically populated with JavaScript -->
        </ul>
    </aside>

    <!-- Main Content for Questions -->
    <div class="question-container">
        <!-- Introduction Section -->
        <div id="intro-section" class="intro-section">
            <h2>{{ translations.exam }} {{ test_number }}</h2>
            <p id="intro-text">
                {{ translations.intro_text|safe }}
            </p>
            
            <!-- Flag System Description -->
            <div class="flag-description">
                <p>
                    <span class="status-circle status-flagged"></span>
                    <strong>{{ translations.flagged }}:</strong> {{ translations.flagged_description }}
                </p>
                <p>
                    <span class="status-circle status-correct"></span>
                    <strong>{{ translations.correct }}:</strong> {{ translations.correct_description }}
                </p>
                <p>
                    <span class="status-circle status-incorrect"></span>
                    <strong>{{ translations.incorrect }}:</strong> {{ translations.incorrect_description }}
                </p>
            </div>

            <div id="exam-details">
                <p><strong>{{ translations.mode }}:</strong> {{ translations.review_mode }} ({{ translations.immediate_feedback }})</p>
                <p><strong>{{ translations.language }}:</strong> {{ exam.get_language_display }}</p>
                <p><strong>{{ translations.exam_format }}:</strong> 65 {{ translations.multiple_choice_questions }}</p>
                <p><strong>{{ translations.difficulty_level }}:</strong> {{ translations.beginner }}</p>
            </div>
            <button onclick="startExam()" id="start-exam-btn" class="start-button">{{ translations.start_exam }}</button>
        </div>
    
        <!-- Question Section (Initially Hidden) -->
        <div id="question-section" class="hidden">
            <h2 id="question-title">
                <span id="question-number">{{ translations.question }} 1</span>
                <span id="question-status" class="status-circle"></span>
                <button id="flag-btn" class="flag-button" onclick="toggleFlag()" aria-label="{{ translations.flag_question }}">
                    &#9873; <!-- Flag icon -->
                </button>
            </h2>
            <p id="situation-text" class="situation"></p>
            <p id="question-text"></p>
            <ul id="options-list"></ul>

            <!-- Submit Button and Feedback Section -->
            <button onclick="submitAnswer()" id="submit-btn" class="submit-button">{{ translations.submit }}</button>
            <div id="feedback" class="feedback hidden">
                <p id="feedback-message"></p>
                <p><strong>{{ translations.correct_answer }}:</strong> <span id="correct-answer"></span></p>
                <p><strong>{{ translations.explanation }}:</strong> <span id="explanation-text"></span></p>
                <div id="other-options-section">
                    <p class="other-options-heading">{{ translations.other_options_heading }}:</p>
                    <ul id="other-options"></ul>
                </div>
            </div>

            <!-- Navigation Buttons -->
            <div class="navigation">
                <button onclick="prevQuestion()" id="prev-btn" class="nav-button">{{ translations.previous }}</button>
                <button onclick="nextQuestion()" id="next-btn" class="nav-button">{{ translations.next }}</button>
                <!-- Finish Button Added Here -->
                <button onclick="finishExam()" id="finish-btn" class="nav-button finish-button2">{{ translations.finish }}</button>
            </div>
        </div>

        <!-- Results Section (Initially Hidden) -->
        <div id="results-section" class="hidden">
            <h2>{{ translations.exam_results }}</h2>
            <p id="results-summary"></p>
            <p id="score-percentage"></p>
            <p id="pass-status"></p>
            <!-- Review Mode Button -->
            <button onclick="enterReviewMode()" id="review-btn" class="review-button">{{ translations.review_answers }}</button>
            <button onclick="retakeExam()" id="retake-btn" class="retake-button">{{ translations.retake_exam }}</button>
        </div>

        <!-- Review Mode Section (Initially Hidden) -->
        <div id="review-section" class="hidden">
            <div class="review-header">
                <h2>{{ translations.review_mode }}</h2>
                <p>{{ translations.review_mode_description }}</p>
            </div>
            <div class="review-questions">
                <!-- Dynamically populated with JavaScript -->
            </div>
            <button onclick="exitReviewMode()" id="exit-review-btn" class="exit-review-button">{{ translations.back_to_results }}</button>
        </div>
    </div>
</div>

<!-- JavaScript Code -->
<script>
    // Pass the current exam ID, test number, and course ID from Django to JavaScript
    const currentExamId = "{{ exam.id }}";
    const testNumber = "{{ test_number }}";
    const courseId = "{{ exam.id }}"; // Assuming exam.id is the course_id
    const questions = JSON.parse('{{ questions_json|escapejs }}');
    let currentQuestion = 0;
    let selectedAnswer = null;
    const passing_score = "{{ score }}"

    // Initialize user responses
    let userResponses = Array(questions.length).fill(null).map(() => ({
        selectedAnswer: null,
        selectedAnswers: [],
        isCorrect: null,
        feedbackMessage: "",
        correctAnswer: "",
        explanation: "",
        otherOptions: [],
        flagged: false
    }));

    const mode = 'review'; // For Review Mode

    // Define a unique key for each exam and test number in localStorage
    const localStorageKey = `userResponses_course_${courseId}_test_${testNumber}_mode_${mode}`;

    // Load user responses from localStorage if available
    const savedResponses = localStorage.getItem(localStorageKey);
    if (savedResponses) {
        try {
            userResponses = JSON.parse(savedResponses);
            // Ensure that userResponses has the correct length
            if (!Array.isArray(userResponses) || userResponses.length !== questions.length) {
                throw new Error("Invalid userResponses data.");
            }
        } catch (error) {
            console.error("Failed to parse userResponses from localStorage:", error);
            // Reset userResponses if parsing fails
            userResponses = Array(questions.length).fill(null).map(() => ({
                selectedAnswer: null,
                selectedAnswers: [],
                isCorrect: null,
                feedbackMessage: "",
                correctAnswer: "",
                explanation: "",
                otherOptions: [],
                flagged: false
            }));
            saveResponses(); // Save the reset responses
        }
    }

    // Initialize exam state variables
    let examStarted = false;

    // Load exam state from localStorage
    const startedState = localStorage.getItem(`examStarted_course_${courseId}_test_${testNumber}_mode_${mode}`);
    if (startedState !== null) {
        examStarted = JSON.parse(startedState);
    }

    // Save exam state to localStorage
    function saveExamState() {
        localStorage.setItem(`examStarted_course_${courseId}_test_${testNumber}_mode_${mode}`, JSON.stringify(examStarted));
    }

    // Save user responses to localStorage whenever they are updated
    function saveResponses() {
        localStorage.setItem(localStorageKey, JSON.stringify(userResponses));
    }

    // Initialize sidebar with question numbers
    function initializeSidebar() {
        const questionList = document.getElementById("question-list");
        questionList.innerHTML = ''; // Clear existing list
        questions.forEach((question, index) => {
            const listItem = document.createElement("li");
            listItem.innerText = "Question " + (index + 1); // Display as "Question 1", "Question 2", etc.
            listItem.classList.add("question-link");
            listItem.setAttribute("data-question-index", index);

            // Determine if the exam is ongoing
            if (examStarted) {
                listItem.onclick = () => displayQuestion(index);
                listItem.classList.remove('disabled');
            } else {
                // Remove onclick handler
                listItem.onclick = null;
                listItem.classList.add('disabled');
            }

            // Add status circle based on user response
            const statusCircle = document.createElement("span");
            statusCircle.classList.add("status-circle");
            if (userResponses[index].isCorrect === true) {
                statusCircle.classList.add("status-correct");
            } else if (userResponses[index].isCorrect === false) {
                statusCircle.classList.add("status-incorrect");
            } else if (userResponses[index].flagged) {
                statusCircle.classList.add("status-flagged");
            }

            listItem.appendChild(statusCircle);

            // Highlight the current question in the sidebar
            if (index === currentQuestion) {
                listItem.classList.add("active");
            }

            questionList.appendChild(listItem);
        });
    }

    function displayQuestion(index) {
        const question = questions[index];
        currentQuestion = index;

        // Reset selectedAnswer
        if (question.Is_Multiple) {
            selectedAnswer = [];
        } else {
            selectedAnswer = null;
        }

        document.getElementById("question-number").innerText = `Question ${index + 1}`;
        const situationElement = document.getElementById("situation-text");
        if (question.Situation) {
            situationElement.innerText = question.Situation;
            situationElement.style.display = 'block'; // Ensure the situation text is visible
        } else {
            situationElement.innerText = '';
            situationElement.style.display = 'none'; // Hide the situation text element
        }
        document.getElementById("question-text").innerText = question.Question;
        
        const optionsList = document.getElementById("options-list");
        optionsList.innerHTML = '';

        const userResponse = userResponses[index];

        // Determine if the question allows multiple answers
        const isMultiple = question.Is_Multiple || false;

        // Enable or disable the submit button based on previous answer
        const isAnswered = userResponse && (userResponse.selectedAnswer !== null || (userResponse.selectedAnswers && userResponse.selectedAnswers.length > 0));
        document.getElementById("submit-btn").disabled = isAnswered;

        Object.keys(question.Options).forEach(key => {
            const option = document.createElement("li");
            
            // Custom checkbox or radio button
            const inputCustom = document.createElement("span");
            let inputElement;

            if (isMultiple) {
                inputCustom.classList.add("checkbox-custom");
                inputElement = document.createElement("input");
                inputElement.type = "checkbox";
                inputElement.name = "option";
                inputElement.value = key;
            } else {
                inputCustom.classList.add("radio-custom");
                inputElement = document.createElement("input");
                inputElement.type = "radio";
                inputElement.name = "option";
                inputElement.value = key;
            }

            const labelElement = document.createElement("label");
            labelElement.style.display = "flex";
            labelElement.style.alignItems = "center";
            labelElement.style.width = "100%"; // Ensure the label fills the <li>
                
            labelElement.appendChild(inputElement);
            labelElement.insertAdjacentText('beforeend', question.Options[key]);

            option.classList.add("option");
            option.prepend(inputCustom); // Add custom input before the label
            option.appendChild(labelElement);

            // Pre-select the user's answer if it exists
            if (isMultiple) {
                if (userResponse && userResponse.selectedAnswers && userResponse.selectedAnswers.includes(key)) {
                    inputElement.checked = true;
                    option.classList.add("selected");
                    inputCustom.classList.add("selected");
                    selectedAnswer.push(key);
                }
                // Disable inputs if answered
                if (isAnswered) {
                    inputElement.disabled = true;
                }
            } else {
                if (userResponse && userResponse.selectedAnswer === key) {
                    inputElement.checked = true;
                    option.classList.add("selected");
                    inputCustom.classList.add("selected");
                    selectedAnswer = key;
                }
                // Disable inputs if answered
                if (isAnswered) {
                    inputElement.disabled = true;
                }
            }


            // Add click listener to the entire <li> to select the option
            option.addEventListener('click', function() {
                if (isMultiple) {
                    inputElement.checked = !inputElement.checked;
                    selectOptionMultiple(key, inputElement);
                } else {
                    inputElement.checked = true;
                    selectOption(key, inputElement);
                }
            });


            optionsList.appendChild(option);
        });

        // If the question has been answered, display the feedback
        if (isAnswered) {
            showFeedback(userResponse.isCorrect, question);
        } else {
            // Hide feedback if the question hasn't been answered
            document.getElementById("feedback").classList.add("hidden");
        }

        // Update the flag button state
        updateFlagButton();

        // Update the status circle in the question section
        updateQuestionStatusCircle();

        // Highlight the current question in the sidebar
        highlightCurrentQuestionInSidebar();

        updateNavigationButtons();
    }

    // Highlight the current question in the sidebar
    function highlightCurrentQuestionInSidebar() {
        const questionLinks = document.querySelectorAll(".question-link");
        questionLinks.forEach((link, index) => {
            if (index === currentQuestion) {
                link.classList.add("active");
            } else {
                link.classList.remove("active");
            }
        });
    }

    // Select an option for single-choice questions
    function selectOption(answerKey, inputElement) {
        selectedAnswer = answerKey;
        // Enable the submit button
        document.getElementById("submit-btn").disabled = false;

        // Remove selected style from other options and highlight selected one
        document.querySelectorAll("#options-list li").forEach(el => {
            el.classList.remove("selected");
            el.querySelector(".radio-custom").classList.remove("selected");
        });
        inputElement.parentElement.parentElement.classList.add("selected");
        inputElement.parentElement.previousElementSibling.classList.add("selected");
    }

    // Select options for multiple-choice questions
    function selectOptionMultiple(answerKey, inputElement) {
        if (!selectedAnswer) {
            selectedAnswer = [];
        }

        if (inputElement.checked) {
            // Check if the answerKey is already in selectedAnswer to prevent duplicates
            if (!selectedAnswer.includes(answerKey)) {
                selectedAnswer.push(answerKey);
            }
        } else {
            const index = selectedAnswer.indexOf(answerKey);
            if (index > -1) {
                selectedAnswer.splice(index, 1);
            }
        }

        // Update the option's class based on selection
        if (inputElement.checked) {
            inputElement.parentElement.parentElement.classList.add("selected");
            inputElement.parentElement.previousElementSibling.classList.add("selected");
        } else {
            inputElement.parentElement.parentElement.classList.remove("selected");
            inputElement.parentElement.previousElementSibling.classList.remove("selected");
        }

        // Enable the submit button if at least one option is selected
        document.getElementById("submit-btn").disabled = selectedAnswer.length === 0;
    }

    // Submit Answer Functionality
    function submitAnswer() {
        const question = questions[currentQuestion];
        const isMultiple = question.Is_Multiple || false;

        if (isMultiple) {
            if (!selectedAnswer || selectedAnswer.length === 0) {
                return alert("Please select at least one answer.");
            }
            const correctAnswers = question["Correct Answer"]; // Array of correct answer keys

            if (!Array.isArray(correctAnswers)) {
                console.error("Correct Answer for multiple-choice question should be an array of correct answer keys.");
                return;
            }

            let selectedAnswersList = [];
            selectedAnswer.forEach(element => {
                selectedAnswersList.push(question.Options[element]);
            });

            console.log(selectedAnswersList)
            console.log(correctAnswers)

            // Check if the selected answers match the correct answers
            const isCorrect = arraysEqual(selectedAnswersList.sort(), correctAnswers.sort());

            // Set the feedback message and styling based on correctness
            showFeedback(isCorrect, question);

            // Save the user's response
            userResponses[currentQuestion] = {
                ...userResponses[currentQuestion],
                selectedAnswers: selectedAnswer,
                isCorrect: isCorrect,
                feedbackMessage: isCorrect ? "Correct!" : "Incorrect",
                correctAnswer: correctAnswers,
                explanation: question.Explanation,
                otherOptions: question["Other Options"]
            };
        } else {
            if (selectedAnswer === null) return alert("Please select an answer.");

            const correctAnswerKey = question["Correct Answer"]; // Key
            const isCorrect = question.Options[selectedAnswer] === correctAnswerKey;

            // Set the feedback message and styling based on correctness
            showFeedback(isCorrect, question);

            // Save the user's response
            userResponses[currentQuestion] = {
                ...userResponses[currentQuestion],
                selectedAnswer: selectedAnswer, // Option key
                isCorrect: isCorrect,
                feedbackMessage: isCorrect ? "Correct!" : "Incorrect",
                correctAnswer: correctAnswerKey,
                explanation: question.Explanation,
                otherOptions: question["Other Options"]
            };
        }

        // Save to localStorage
        saveResponses();

        // Disable all inputs after submission
        document.querySelectorAll("#options-list input[name='option']").forEach(input => {
            input.disabled = true;
        });

        // Disable the submit button after submission
        document.getElementById("submit-btn").disabled = true;

        // Update the sidebar to reflect the answered question
        initializeSidebar();

        // Update the status circle in the question section
        updateQuestionStatusCircle();
    }

    // Function to compare two arrays for equality
    function arraysEqual(a1, a2) {
        if (a1.length !== a2.length) {
            return false;
        }
        a1 = a1.slice().sort();
        a2 = a2.slice().sort();
        for (let i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) {
                return false;
            }
        }
        return true;
    }

    // Function to show feedback
    function showFeedback(isCorrect, question) {
        const feedback = document.getElementById("feedback");
        const isMultiple = question.Is_Multiple || false;

        let correctAnswerText = '';
        if (isMultiple) {
            // For multiple-answer questions, display all correct answers
            const correctAnswers = question["Correct Answer"]; // Array of keys
            correctAnswerText = correctAnswers.map(key => {
                return `${key}`;
            }).join('; ');
        } else {
            // For single-answer questions
            const correctAnswerKey = question["Correct Answer"]; // Key
            correctAnswerText = `${correctAnswerKey}`;
        }

        document.getElementById("correct-answer").innerText = correctAnswerText;
        document.getElementById("explanation-text").innerText = question.Explanation;

        // Apply styles for correct or incorrect feedback
        feedback.classList.remove("correct", "incorrect", "shake", "bounce", "glow"); // Remove any previous animations
        feedback.classList.add(isCorrect ? "correct" : "incorrect");

        // Trigger bounce or shake effect based on correctness
        if (isCorrect) {
            feedback.classList.add("bounce"); // Trigger bounce for correct answer
            setTimeout(() => feedback.classList.remove("bounce", "glow"), 1000); // Remove class after animation
        } else {
            feedback.classList.add("shake"); // Trigger shake for incorrect answer
            setTimeout(() => feedback.classList.remove("shake"), 500); // Remove class after animation
        }

        // Display other options explanations
        const otherOptionsList = document.getElementById("other-options");
        otherOptionsList.innerHTML = '';
        question["Other Options"].forEach((optionText, index) => {
            const li = document.createElement("li");
            li.innerText = optionText;
            otherOptionsList.appendChild(li);
        });

        feedback.classList.remove("hidden"); // Show feedback
    }

    // Toggle flag for the current question
    function toggleFlag() {
        const userResponse = userResponses[currentQuestion];
        userResponse.flagged = !userResponse.flagged;

        // Save to localStorage
        saveResponses();

        // Update the sidebar and question section indicators
        initializeSidebar();
        updateFlagButton();
        updateQuestionStatusCircle();
    }

    // Update the flag button appearance
    function updateFlagButton() {
        const flagBtn = document.getElementById("flag-btn");
        const userResponse = userResponses[currentQuestion];
        if (userResponse.flagged) {
            flagBtn.classList.add("flagged");
        } else {
            flagBtn.classList.remove("flagged");
        }
    }

    // Update the status circle next to the question number in the question section
    function updateQuestionStatusCircle() {
        const statusCircle = document.getElementById("question-status");
        statusCircle.className = 'status-circle'; // Reset classes
        const userResponse = userResponses[currentQuestion];

        if (userResponse.isCorrect === true) {
            statusCircle.classList.add("status-correct");
        } else if (userResponse.isCorrect === false) {
            statusCircle.classList.add("status-incorrect");
        } else if (userResponse.flagged) {
            statusCircle.classList.add("status-flagged");
        }
    }

    // Navigation functions
    function scrollToTop() {
        window.scrollTo({
            top: 0,
            behavior: 'smooth' // Smooth scrolling effect
        });
    }

    function prevQuestion() {
        if (currentQuestion > 0) {
            displayQuestion(currentQuestion - 1);
            scrollToTop();
        }
    }

    function nextQuestion() {
        if (currentQuestion < questions.length - 1) {
            displayQuestion(currentQuestion + 1);
            scrollToTop();
        }
    }

    function updateNavigationButtons() {
        document.getElementById("prev-btn").disabled = currentQuestion === 0;
        document.getElementById("next-btn").disabled = currentQuestion === questions.length - 1;
    }

    // Function to check if the exam has been finished
    function checkIfExamFinished() {
        const finishedKey = `examFinished_course_${courseId}_test_${testNumber}_mode_${mode}`;
        const finishedData = localStorage.getItem(finishedKey);
        if (finishedData) {
            try {
                const resultsData = JSON.parse(finishedData);
                // Hide intro and question sections
                document.getElementById("intro-section").classList.add("hidden");
                document.getElementById("question-section").classList.add("hidden");

                // Populate and display the results section
                document.getElementById("results-summary").innerText = `You answered ${resultsData.correctAnswers} out of ${resultsData.totalQuestions} questions correctly.`;
                document.getElementById("score-percentage").innerText = `Your score: ${resultsData.scorePercentage}%`;
                document.getElementById("pass-status").innerText = resultsData.passed ? "Status: Passed" : "Status: Not Passed";
                document.getElementById("results-section").classList.remove("hidden");

                // Update exam state
                examStarted = false;
                saveExamState();
                initializeSidebar();
            } catch (error) {
                console.error("Error parsing finished exam data:", error);
                // If there's an error, consider the exam not finished
            }
        }
    }

    // Initialize sidebar and display the first question or results based on completion status
    initializeSidebar();
    checkIfExamFinished();

    if (!document.getElementById("results-section").classList.contains("hidden")) {
        // Exam is finished
        examStarted = false;
        saveExamState();
        initializeSidebar();
    } else if (examStarted) {
        // Exam is ongoing
        // Hide the introduction section
        document.getElementById("intro-section").classList.add("hidden");
        // Show the question section
        document.getElementById("question-section").classList.remove("hidden");
        displayQuestion(currentQuestion);
        initializeSidebar();
    } else {
        // Exam not started
        document.getElementById("intro-section").classList.remove("hidden");
        // Hide question section
        document.getElementById("question-section").classList.add("hidden");
        examStarted = false;
        saveExamState();
        initializeSidebar();
    }

    function startExam() {
        // Hide the introduction section
        document.getElementById("intro-section").classList.add("hidden");

        // Show the question section and initialize the first question
        document.getElementById("question-section").classList.remove("hidden");
        displayQuestion(currentQuestion);

        // Set examStarted to true and save state
        examStarted = true;
        saveExamState();

        // Update the sidebar
        initializeSidebar();
    }

    // Finish Exam Functionality
    function finishExam() {
        const unanswered = userResponses.filter(response => response.selectedAnswer === null && (!response.selectedAnswers || response.selectedAnswers.length === 0)).length;
        if (unanswered > 0) {
            const confirmFinish = confirm(`You have ${unanswered} unanswered question(s). Are you sure you want to finish the exam?`);
            if (!confirmFinish) {
                return; // User chose to continue the exam
            }
        }

        // Calculate results
        const totalQuestions = questions.length;
        const correctAnswers = userResponses.filter(response => response.isCorrect).length;
        const scorePercentage = ((correctAnswers / totalQuestions) * 100).toFixed(2);
        const passed = scorePercentage >= passing_score;

        // Hide the question section
        document.getElementById("question-section").classList.add("hidden");

        // Display results in the results section
        document.getElementById("results-summary").innerText = `You answered ${correctAnswers} out of ${totalQuestions} questions correctly.`;
        document.getElementById("score-percentage").innerText = `Your score: ${scorePercentage}%`;
        document.getElementById("pass-status").innerText = passed ? "Status: Passed" : "Status: Not Passed";

        // Show the results section
        document.getElementById("results-section").classList.remove("hidden");

        // Set the "finished" flag in localStorage
        const resultsData = {
            totalQuestions,
            correctAnswers,
            scorePercentage,
            passed
        };
        localStorage.setItem(`examFinished_course_${courseId}_test_${testNumber}_mode_${mode}`, JSON.stringify(resultsData));

        // Update exam state
        examStarted = false;
        saveExamState();

        // Update the sidebar
        initializeSidebar();

        updateUserProgress();
    }

    function updateUserProgress() {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', '{% url "update_exam_progress" %}', true);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        // Include CSRF token
        const csrftoken = getCookie('csrftoken'); // Implement getCookie() to retrieve the CSRF token
        xhr.setRequestHeader('X-CSRFToken', csrftoken);

        xhr.onreadystatechange = function() {
            if (xhr.readyState === XMLHttpRequest.DONE) {
                if (xhr.status === 200) {
                    console.log('Progress updated successfully');
                } else {
                    console.error('Failed to update progress');
                }
            }
        };

        const params = `course_id=${encodeURIComponent(courseId)}&exam_number=${encodeURIComponent(testNumber)}&mode=${encodeURIComponent(mode)}`;

        xhr.send(params);
    }

    // Utility function to get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                cookie = cookie.trim();
                if (cookie.startsWith(name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Retake Exam Functionality
    function retakeExam() {
        // Confirm with the user
        const confirmRetake = confirm("Are you sure you want to retake the exam? All your current progress will be lost.");
        if (!confirmRetake) {
            return;
        }

        // Define the key used to store the "finished" flag
        const finishedKey = `examFinished_course_${courseId}_test_${testNumber}_mode_${mode}`;

        // Remove the "finished" flag from localStorage
        localStorage.removeItem(finishedKey);

        // Reset user responses
        userResponses = Array(questions.length).fill(null).map(() => ({
            selectedAnswer: null,
            selectedAnswers: [],
            isCorrect: null,
            feedbackMessage: "",
            correctAnswer: "",
            explanation: "",
            otherOptions: [],
            flagged: false
        }));

        // Save the reset responses to localStorage
        saveResponses();

        // Reset exam state
        examStarted = false;
        saveExamState();

        // Reset UI elements
        document.getElementById("results-section").classList.add("hidden");
        document.getElementById("intro-section").classList.remove("hidden");

        // Re-initialize sidebar
        initializeSidebar();

        // Reset navigation buttons if needed
        currentQuestion = 0;
    }

    // Back Button Functionality
    function goBack() {
        window.location.href = "{% url 'exam_selection' exam.id %}";
    }

    // Enter Review Mode
    function enterReviewMode() {
        // Hide the results section
        document.getElementById("results-section").classList.add("hidden");

        // Show the review section
        document.getElementById("review-section").classList.remove("hidden");

        // Set examStarted to false to disable sidebar links
        examStarted = false;
        saveExamState();

        // Update the sidebar
        initializeSidebar();

        // Populate the review section with all questions and feedback
        populateReviewSection();
    }

    // Exit Review Mode
    function exitReviewMode() {
        // Hide the review section
        document.getElementById("review-section").classList.add("hidden");

        // Show the results section
        document.getElementById("results-section").classList.remove("hidden");

        // Update the sidebar
        initializeSidebar();
    }

    // Populate Review Section with Questions and Feedback
    // Populate Review Section with Questions and Feedback
    function populateReviewSection() {
        const reviewContainer = document.querySelector(".review-questions");
        reviewContainer.innerHTML = ''; // Clear existing content

        questions.forEach((question, index) => {
            const userResponse = userResponses[index];
            const isCorrect = userResponse.isCorrect;
            const isMultiple = question.Is_Multiple || false;

            // Create question card
            const questionCard = document.createElement("div");
            questionCard.classList.add("review-question-card");
            const correctAnswerText = question["Correct Answer"]; // Correct answer text

            // Question Header
            const questionHeader = document.createElement("div");
            questionHeader.classList.add("review-question-header");
            questionHeader.innerHTML = 
                `<h3>Question ${index + 1}</h3>
                <span class="review-status ${isCorrect ? 'correct' : 'incorrect'}">
                    ${isCorrect ? '✔️ Correct' : '❌ Incorrect'}
                </span>`;

            // Question Body
            const questionBody = document.createElement("div");
            questionBody.classList.add("review-question-body");
            questionBody.innerHTML = 
                `<p><strong>Situation:</strong> ${question.Situation}</p>
                <p><strong>Question:</strong> ${question.Question}</p>
                <ul class="review-options">
                    ${Object.keys(question.Options).map(key => {
                        const optionText = question.Options[key];
                        let liClass = '';
                        let label = '';

                        if (isMultiple) {
                            // Map correct answer texts to their keys
                            const correctAnswers = [];
                            for (const [optKey, optValue] of Object.entries(question.Options)) {
                                if (question["Correct Answer"].includes(optValue)) {
                                    correctAnswers.push(optKey);
                                }
                            }
                            const userAnswers = userResponse.selectedAnswers || [];

                            if (correctAnswers.includes(key) && userAnswers.includes(key)) {
                                // User selected the correct answer
                                liClass = 'correct-answer';
                                label = '(Your Answer)';
                            } else if (correctAnswers.includes(key)) {
                                // Correct answer not selected by user
                                liClass = 'correct-answer';
                                label = '(Correct Answer)';
                            } else if (userAnswers.includes(key)) {
                                // User's selected incorrect answer
                                liClass = 'incorrect-answer selected-answer';
                                label = '(Your Answer)';
                            }
                        } else {
                            const userAnswerKey = userResponse.selectedAnswer;
                            let correctAnswerKey = null;
                            for (const [optKey, optValue] of Object.entries(question.Options)) {
                                if (optValue === question["Correct Answer"]) {
                                    correctAnswerKey = optKey;
                                    break;
                                }
                            }

                            if (key === correctAnswerKey && key === userAnswerKey) {
                                // User selected the correct answer
                                liClass = 'correct-answer';
                                label = '(Your Answer)';
                            } else if (key === correctAnswerKey) {
                                // Correct answer
                                liClass = 'correct-answer';
                                label = '(Correct Answer)';
                            } else if (key === userAnswerKey) {
                                // User's selected incorrect answer
                                liClass = 'incorrect-answer selected-answer';
                                label = '(Your Answer)';
                            }
                        }

                        return `
                            <li class="${liClass}">
                                <strong>${key}.</strong> ${optionText} ${label ? '<span class="answer-label"> ' + label + '</span>' : ''}
                            </li>
                        `;
                    }).join('')}
                </ul>`;

            // Feedback Section
            const feedbackSection = document.createElement("div");
            feedbackSection.classList.add("feedback", isCorrect ? "correct" : "incorrect");
            feedbackSection.innerHTML = 
                `
                <p><strong>Correct Answer:</strong> ${correctAnswerText}</p>
                <p><strong>Explanation:</strong> ${question.Explanation}</p>
                <div class="other-options-section">
                    <p class="other-options-heading">Other Options:</p>
                    <ul id="other-options">
                        ${question["Other Options"].map(optionText => `<li>${optionText}</li>`).join('')}
                    </ul>
                </div>`;

            // Append all parts to the question card
            questionCard.appendChild(questionHeader);
            questionCard.appendChild(questionBody);
            questionCard.appendChild(feedbackSection);

            // Append the question card to the review container
            reviewContainer.appendChild(questionCard);
        });
    }


</script>
{% endblock %}
